<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="description" content="three.jsで道路の自動生成。木も描画。">
  <title>three.js Road make 4</title>
  <style>
    body {
      margin: 0px;
      padding: 0px;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <!-- three.js を読み込む -->
  <script src="three.min.js"></script>

  <script>
    var renderer, camera, scene;
    var startTime;
    var road;
    var gTime;
    var geom, geomBg, group;
    var mesh, meshBg;
    var texture, textureBg, texTrees;
    var matTrees;

    // var bgColor = 0xaed2ff;
    // var bgColor = 0xd0e0ff;
    var bgColor = 0xe8f0ff;

    // 時間測定用メソッドを定義
    var now = window.performance && (
      performance.now ||
      performance.mozNow ||
      performance.msNow ||
      performance.oNow ||
      performance.webkitNow);

    var getTime = function () {
      return (now && now.call(performance)) || (new Date().getTime());
    }

    // min から max までの乱数(実数)を返す
    function getRandomArbitary(min, max) {
      return Math.random() * (max - min) + min;
    }

    // 度からラジアンに変換
    function deg2rad(deg) {
      return deg * Math.PI / 180.0;
    }

    function easeInOutQuad(t, b, c, d) {
      t /= (d / 2.0);
      if (t < 1.0) return (c / 2.0 * t * t + b);
      t -= 1.0;
      return (-c / 2.0 * (t * (t - 2.0) - 1.0) + b);
    };

    function easeInOutCubic(t, b, c, d) {
      t /= (d / 2.0);
      if (t < 1.0) return (c / 2.0 * t * t * t + b);
      t -= 2.0;
      return (c / 2.0 * (t * t * t + 2.0) + b);
    };

    function easeInOutQuint(t, b, c, d) {
      t /= (d / 2.0);
      if (t < 1.0) return (c / 2.0 * t * t * t * t * t + b);
      t -= 2.0;
      return (c / 2.0 * (t * t * t * t * t + 2.0) + b);
    };

    function easeInOutExpo(t, b, c, d) {
      t /= (d / 2.0);
      if (t < 1.0) return (c / 2.0 * pow(2, 10 * (t - 1)) + b);
      t -= 1.0;
      return (c / 2.0 * (-pow(2, -10 * t) + 2.0) + b);
    };

    function getLinearValue(t, vStart, vEnd) {
      return vStart + ((vEnd - vStart) * t);
    };

    // 線分が交差してるか調べる。trueなら交差。falseなら交差してない。
    function checkLineCross(a, b, c, d) {
      var cx, cy, bx, by, dx, dy;
      cx = c.x - a.x;
      cy = c.y - a.y;
      bx = b.x - a.x;
      by = b.y - a.y;
      dx = d.x - a.x;
      dy = d.y - a.y;
      if ((cx * by - cy * bx) * (dx * by - dy * bx) > 0) return false;
      cx = a.x - c.x;
      cy = a.y - c.y;
      bx = d.x - c.x;
      by = d.y - c.y;
      dx = b.x - c.x;
      dy = b.y - c.y;
      if ((cx * by - cy * bx) * (dx * by - dy * bx) > 0) return false;
      return true;
    };

    // THREE.Vector3 を4つ(線分を2つ)与えて、x,z座標で交差を調べる
    function checkLineCrossXZ(a, b, c, d) {
      var e, f, g, h;
      e = new THREE.Vector2(a.x, a.z);
      f = new THREE.Vector2(b.x, b.z);
      g = new THREE.Vector2(c.x, c.z);
      h = new THREE.Vector2(d.x, d.z);
      return checkLineCross(e, f, g, h);
    };

    // 道路生成用クラス
    var Road = (function () {
      var Road = function (geom, group, matTrees) {
        this.geom = geom;
        this.group = group;
        this.matTrees = matTrees;

        this.camPos = new THREE.Vector3(0, 0, 0);
        this.camTgt = new THREE.Vector3(0, 0, 0);
        this.camAngle = 0;

        this.idx = 0;
        this.roadWidth = 200 / 2; // 道路の幅(片方の幅)
        this.roadDist = 96; // 道路の一片の長さ
        this.texNum = 0; // テクスチャ種類(0 or 1)
        this.t = 0.0; // 時間(進行度)
        this.vDur = 1.0;

        this.startAngXZ = 270.0;
        this.changeAngXZ = 0.0;
        this.angXZ = this.startAngXZ;

        this.startAngZY = 0.0;
        this.changeAngZY = 0.0;
        this.angZY = this.startAngZY;

        this.pnt = new THREE.Vector3(0, 0, 0);
        this.tSpd = 0.0;

        this.setNextChangeValue();

        this.linePos = [];
        this.texNums = [];
        this.pnts = [];
        this.treesPnts = [];
        this.treesScale = [];
        this.treesTexNum = [];
        this.trees = [];

        for (var i = 0; i < 80; i++) {
          for (var j = 0; j < 12; j++) {
            this.pnts.push(new THREE.Vector3(0, 0, 0));
          }

          this.linePos.push([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 0)
          ]);

          this.texNums.push(0);

          for (var j = 0; j < 4; j++) {
            this.treesPnts.push(new THREE.Vector3());
            this.treesScale.push(0);
            this.treesTexNum.push(0);
          }
        }

        for (var i = 0; i < this.texNums.length; i++) {
          this.pushNewPos(i);
        }

        this.initGeom(geom, group, matTrees);
      };

      var p = Road.prototype;

      // 角度の変化量と変化速度を更新
      p.setNextChangeValue = function () {
        this.changeAngXZ = getRandomArbitary(-80.0, 80.0);
        this.changeAngZY = getRandomArbitary(-10.0, 10.0);
        if ((this.startAngZY + this.changeAngZY) > 18) {
          this.changeAngZY = 18 - this.startAngZY;
        }
        if ((this.startAngZY + this.changeAngZY) < -18) {
          this.changeAngZY = -18 - this.startAngZY;
        }
        this.tSpd = getRandomArbitary(0.015, 0.04);
      };

      // 時間(進行度)を進める
      p.setNextTime = function () {
        this.t += this.tSpd;
        if (this.t >= 1.0) {
          this.t -= 1.0;
          this.startAngXZ += this.changeAngXZ;
          this.startAngZY += this.changeAngZY;
          this.setNextChangeValue();
        }
      };

      // 道路片参照インデックス値を更新
      p.incIndex = function () {
        this.pushNewPos(this.idx);
        this.updateTreesPos(this.idx);
        this.idx = (this.idx + 1) % this.texNums.length;
      };

      // 座標を生成して配列に記録
      p.pushNewPos = function (idx) {
        // 道路の線分の現座標値を取得
        var l0 = new THREE.Vector3(this.pnt.x, this.pnt.y, this.pnt.z);
        var a0 = this.angXZ;

        // 道路の線分の次の座標値を取得
        this.angXZ = easeInOutQuad(this.t, this.startAngXZ, this.changeAngXZ, this.vDur);
        this.angZY = easeInOutQuad(this.t, this.startAngZY, this.changeAngZY, this.vDur);
        var dx = deg2rad(this.angXZ);
        var dy = deg2rad(this.angZY);
        this.pnt.x = this.roadDist * Math.cos(dx) + this.pnt.x;
        this.pnt.y = this.roadDist * Math.sin(dy) + this.pnt.y;
        this.pnt.z = this.roadDist * Math.sin(dx) + this.pnt.z;

        // 線分情報を記録
        this.linePos[idx][0].set(l0.x, l0.y, l0.z);
        this.linePos[idx][1].set(this.pnt.x, this.pnt.y, this.pnt.z);

        // 頂点座標を更新
        this.setData(idx, l0, a0, this.pnt, this.angXZ, this.roadWidth);

        // テクスチャ種類を更新
        this.texNums[idx] = this.texNum;
        this.texNum = (this.texNum + 1) % 2;

        this.setNextTime();
      };

      p.getLinePos = function (i) {
        return this.linePos[i % this.linePos.length];
      };

      // 頂点情報を設定
      p.setData = function (idx, l0, ang0, l1, ang1, roadW) {
        var w0 = roadW; // 道路の幅
        var w1 = roadW + (roadW * 12); // 道路脇の幅
        var ya = -w1 * 0.5; // 道路脇(左)の高さ
        var yb = w1 * 0.7; // 道路脇(右)の高さ

        // 道路、道路脇のポリゴン座標群を取得
        var i = idx * (6 * 2);
        this.setPntOneLine(i + 0, l1, ang1, w0, w1, ya, yb);
        this.setPntOneLine(i + 6, l0, ang0, w0, w1, ya, yb);

        // 道路脇ポリゴンの前後が交差してないかチェック
        var lst = [
          [0, 1, 6, 7],
          [1, 2, 7, 8],
          [4, 3, 10, 9],
          [5, 4, 11, 10]
        ];
        for (var j = 0; j < lst.length; j++) {
          var a = lst[j][0];
          var b = lst[j][1];
          var c = lst[j][2];
          var d = lst[j][3];
          if (checkLineCrossXZ(this.pnts[a], this.pnts[b], this.pnts[c], this.pnts[d])) {
            // 交差してたら座標を交換する
            var x = this.pnts[a].x;
            var z = this.pnts[a].z;
            this.pnts[a].setX(this.pnts[c].x);
            this.pnts[a].setZ(this.pnts[c].z);
            this.pnts[c].setX(x);
            this.pnts[c].setZ(z);
          }
        }

        // 木の位置を登録
        j = idx * 4;
        var sc = [160, 300, 160, 400];
        this.setTreeOneLine(j + 0, this.pnts[i + 1], this.pnts[i + 0], 0.0, 1.0, sc[0], sc[1]);
        this.setTreeOneLine(j + 1, this.pnts[i + 2], this.pnts[i + 1], 0.22, 1.0, sc[0], sc[1]);
        this.setTreeOneLine(j + 2, this.pnts[i + 3], this.pnts[i + 4], 0.08, 1.0, sc[2], sc[3]);
        this.setTreeOneLine(j + 3, this.pnts[i + 4], this.pnts[i + 5], 0.0, 1.0, sc[2], sc[3]);
      };

      // 座標と角度から頂点座標群を取得
      p.setPntOneLine = function (i, l0, ang0, w0, w1, ya, yb) {
        var a0 = deg2rad(ang0 - 90);
        var a1 = deg2rad(ang0 + 90);
        var w2 = w1 / 2;
        var c0 = Math.cos(a0);
        var c1 = Math.cos(a1);
        var s0 = Math.sin(a0);
        var s1 = Math.sin(a1);
        this.pnts[i + 0].set(w1 * c0 + l0.x, l0.y + ya, w1 * s0 + l0.z);
        this.pnts[i + 1].set(w2 * c0 + l0.x, l0.y + ya * 0.35, w2 * s0 + l0.z);
        this.pnts[i + 2].set(w0 * c0 + l0.x, l0.y, w0 * s0 + l0.z);
        this.pnts[i + 3].set(w0 * c1 + l0.x, l0.y, w0 * s1 + l0.z);
        this.pnts[i + 4].set(w2 * c1 + l0.x, l0.y + yb * 0.35, w2 * s1 + l0.z);
        this.pnts[i + 5].set(w1 * c1 + l0.x, l0.y + yb, w1 * s1 + l0.z);
      };

      // 木の位置を登録
      p.setTreeOneLine = function (i, p0, p1, a0, a1, s0, s1) {
        var w = getRandomArbitary(s0, s1);
        r = getRandomArbitary(a0, a1);
        var x = p0.x + (p1.x - p0.x) * r;
        var y = p0.y + (p1.y - p0.y) * r + (w / 2) - 24;
        var z = p0.z + (p1.z - p0.z) * r;
        this.treesPnts[i].set(x, y, z);
        this.treesScale[i] = w;
        this.treesTexNum[i] = Math.floor(Math.random() * 4);
      };

      // 道路の線分情報を元にして、カメラ位置、注視位置、カメラ角度を取得
      p.setCameraPos = function (t) {
        // 道路中央の線分を得て、どのあたりに居るかを得る
        var l0 = this.getLinePos(this.idx + 1);
        var l1 = this.getLinePos(this.idx + 12);

        var lx0 = getLinearValue(t, l0[0].x, l0[1].x);
        var ly0 = getLinearValue(t, l0[0].y, l0[1].y);
        var lz0 = getLinearValue(t, l0[0].z, l0[1].z);

        var lx1 = getLinearValue(t, l1[0].x, l1[1].x);
        // var ly1 = getLinearValue(t, l1[0].y, l1[1].y);
        var lz1 = getLinearValue(t, l1[0].z, l1[1].z);

        var ty = 70;

        // カメラ位置座標
        this.camPos.set(lx0, ly0 + ty, lz0);

        // カメラ注視点座標
        this.camTgt.set(lx1, ly0 + ty, lz1);

        // カメラ角度
        var y = this.camTgt.z - this.camPos.z;
        var x = this.camTgt.x - this.camPos.x;
        this.camAngle = Math.atan2(y, x);
      };

      // Geometry を生成
      p.initGeom = function (geom, group, matTrees) {

        // 頂点群を登録
        for (var j = 0; j < this.pnts.length; j++) {
          geom.vertices.push(this.pnts[j]);
        }

        var b = 0;
        for (var i = 0; i < this.texNums.length; i++) {

          // ポリゴンを Geometry に登録
          // 頂点は反時計回りで並べる
          for (var j = 0; j < 5; j++) {
            var k = b + j;
            geom.faces.push(new THREE.Face3(k + 6, k + 1, k + 0));
            geom.faces.push(new THREE.Face3(k + 6, k + 7, k + 1));
          }

          // テクスチャ座標を取得
          var tk = this.texNums[i];
          var u0 = 0.0;
          var u1 = 0.5;
          var u2 = 1.0;
          var v0 = 1.0 - (tk * 0.5);
          var v1 = 0.5 - (tk * 0.5);

          var tRoadA = [
              new THREE.Vector2(u0, v1),
              new THREE.Vector2(u1, v0),
              new THREE.Vector2(u0, v0)
          ];

          var tRoadB = [
              new THREE.Vector2(u0, v1),
              new THREE.Vector2(u1, v1),
              new THREE.Vector2(u1, v0)
          ];

          var tGrassA = [
              new THREE.Vector2(u1, v1),
              new THREE.Vector2(u2, v0),
              new THREE.Vector2(u1, v0)
          ];

          var tGrassB = [
              new THREE.Vector2(u1, v1),
              new THREE.Vector2(u2, v1),
              new THREE.Vector2(u2, v0)
          ];

          // テクスチャ座標設定
          geom.faceVertexUvs[0].push(
            tGrassA, tGrassB,
            tGrassA, tGrassB,
            tRoadA, tRoadB,
            tGrassA, tGrassB,
            tGrassA, tGrassB
          );

          b += (6 * 2);
        }

        this.trees = [];
        for (var i = 0, len = this.treesPnts.length; i < len; i++) {
          var tree = new THREE.Sprite(matTrees[this.treesTexNum[i]]);
          var tp = this.treesPnts[i];
          var w = this.treesScale[i];
          tree.position.set(tp.x, tp.y, tp.z);
          tree.scale.set(w, w, 1);
          group.add(tree);
          this.trees.push(tree);
        }
      };

      p.updateTreesPos = function (idx) {
        var i = idx * 4;
        for (var i = idx * 4, len = idx * 4 + 4; i < len; i++) {
          var tree = this.trees[i];
          var tp = this.treesPnts[i];
          var w = this.treesScale[i];
          tree.position.set(tp.x, tp.y, tp.z);
          tree.scale.set(w, w, 1);
        }
      };

      return Road;
    })();

    // Mesh生成
    function initMesh(scene) {

      // マテリアル作成
      var material = new THREE.MeshLambertMaterial({
        map: texture,
        fog: true,
      });

      matTrees = [];
      for (var i = 0, len = texTrees.length; i < len; i++) {
        matTrees.push(new THREE.SpriteMaterial({
          map: texTrees[i],
          fog: true,
          color: 0xffffff,
        }));
      }

      // メッシュ作成
      geom = new THREE.Geometry();
      group = new THREE.Group();
      road = new Road(geom, group, matTrees);

      // mergeVertices() を入れると描画がおかしくなる
      //geom.mergeVertices();

      // 法線ベクトル生成(自動計算)
      geom.computeFaceNormals();
      geom.computeVertexNormals();
      geom.computeBoundingSphere();

      // メッシュをシーンに追加
      mesh = new THREE.Mesh(geom, material);
      scene.add(mesh);

      scene.add(group);

      // 頂点座標が一部変化するのでGeometryを更新可能にしておく
      geom.dynamic = true;

      // BG
      geomBg = new THREE.SphereGeometry(7500, 60, 40);
      geomBg.scale(-1, 1, 1);
      var matBg = new THREE.MeshBasicMaterial({
        map: textureBg,
        fog: true,
        // fog: false,
      });
      meshBg = new THREE.Mesh(geomBg, matBg);
      scene.add(meshBg);
    };

    window.addEventListener("DOMContentLoaded", function () {

      // レンダラー生成
      renderer = new THREE.WebGLRenderer({
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 背景色指定
      renderer.setClearColor(new THREE.Color(bgColor));

      // カメラ生成
      var fov = 60;
      var aspect = window.innerWidth / window.innerHeight;
      var near = 2;
      var far = 9999;
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 100, 100);
      camera.up.set(0, 1, 0);

      // テクスチャ読み込み
      texture = new THREE.TextureLoader().load('images/road2.png');

      // テクスチャの品質を良くする
      texture.anisotropy = renderer.getMaxAnisotropy();
      // texture.magFilter = THREE.LinearFilter;
      // texture.minFilter = THREE.LinearFilter;

      // 背景テクスチャ読み込み
      textureBg = new THREE.TextureLoader().load("images/bg.jpg");
      textureBg.anisotropy = renderer.getMaxAnisotropy();

      // 木のテクスチャを読み込み
      var treeTexList = [
        "images/tree0.png",
        "images/tree1.png",
        "images/tree2.png",
        "images/tree3.png",
      ];

      texTrees = [];
      for (var i = 0, len = treeTexList.length; i < len; i++) {
        texTrees.push(new THREE.TextureLoader().load(treeTexList[i]));
        texTrees[i].anisotropy = renderer.getMaxAnisotropy();
      }

      // シーン生成
      scene = new THREE.Scene();

      // シーンにフォグを設定
      //scene.fog = new THREE.FogExp2(bgColor, 0.00035);
      scene.fog = new THREE.FogExp2(bgColor, 0.00012);

      // 平行光源生成
      var light1 = new THREE.DirectionalLight(0xcccccc, 1.6);
      light1.position.set(-100, 200, 100); // ライトの位置
      // light1.lookAt(new THREE.Vector3(0, 0, 0)); // ライトの向き
      scene.add(light1);

      // 環境光源生成
      var light2 = new THREE.AmbientLight(0x333333);
      scene.add(light2);

      // スポットライト生成
      // 光源色、光強度、光源からの減衰係数、光源の傾き、光源軸からの減衰係数
      //var light3 = new THREE.SpotLight(0xFFFFFF, 4, 0, Math.PI / 3, 20);
      //light3.target.position = new THREE.Vector3(0, 0, 0);
      //light3.position.set(0, 100, 100);
      //scene.add(light3);

      // メッシュ生成
      initMesh(scene);

      // アニメさせる
      gTime = 0;
      startTime = getTime();

      function rendering() {
        // 前フレームからの経過時間を取得
        var lastTime = getTime();
        var dt = (lastTime - startTime) / 1000.0;

        // 時間を進める
        gTime += dt * 7;
        if (gTime >= 1.0) {
          road.incIndex();
          gTime -= 1.0;

          // 頂点座標が一部変化するのでGeometryを更新
          geom.verticesNeedUpdate = true;
          geom.elementsNeedUpdate = true;
          geom.normalsNeedUpdate = true;
          geom.uvsNeedUpdate = true;

          // 法線ベクトル等を再計算
          geom.computeFaceNormals();
          geom.computeVertexNormals();
          geom.computeBoundingSphere();
        }

        road.setCameraPos(gTime);

        var cTgt = road.camTgt;
        camera.lookAt({
          x: cTgt.x,
          y: cTgt.y,
          z: cTgt.z
        });
        camera.position.set(road.camPos.x, road.camPos.y, road.camPos.z);
        camera.up.set(0, 1, 0);

        meshBg.position.set(road.camPos.x, road.camPos.y, road.camPos.z);

        //mesh.rotation.y += 0.5 * dt;
        renderer.clear();
        renderer.render(scene, camera);

        startTime = lastTime;
        requestAnimationFrame(rendering);
      }
      rendering();
    });

    // ウインドウリサイズ時の処理
    window.addEventListener('resize', function () {
      var w = window.innerWidth;
      var h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }, false);
  </script>
</body>

</html>